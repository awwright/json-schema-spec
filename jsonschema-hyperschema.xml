<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2046 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2046.xml">
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY rfc4151 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4151.xml">
<!--<!ENTITY rfc4287 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4287.xml">-->
<!--<!ENTITY rfc5226 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">-->
<!ENTITY rfc5789 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5789.xml">
<!ENTITY rfc5988 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5988.xml">
<!ENTITY rfc6570 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6570.xml">
<!ENTITY rfc6573 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6573.xml">
<!ENTITY rfc6901 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6901.xml">
<!ENTITY rfc7231 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7231.xml">
<!ENTITY I-D.nottingham-rfc5988bis SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-nottingham-rfc5988bis-08.xml">
<!ENTITY I-D.luff-relative-json-pointer SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-luff-relative-json-pointer-00.xml">
<!ENTITY I-D.kelly-json-hal SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-kelly-json-hal-08.xml">
<!ENTITY I-D.reschke-http-jfv SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-reschke-http-jfv-06.xml">
<!ENTITY ldp SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml4/reference.W3C.REC-ldp-20150226.xml">
]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes" ?>
<rfc category="info" docName="draft-wright-json-schema-hyperschema-02" ipr="trust200902">
    <front>
        <title abbrev="JSON Hyper-Schema">
            JSON Hyper-Schema: A Vocabulary for Hypermedia Annotation of JSON
        </title>

        <author fullname="Austin Wright" initials="A" surname="Wright" role="editor">
            <address>
                <email>aaa@bzfx.net</email>
            </address>
        </author>

        <author fullname="Henry Andrews" initials="H" surname="Andrews" role="editor">
            <organization>Cloudflare, Inc.</organization>
            <address>
                <email>henry@cloudflare.com</email>
            </address>
        </author>

        <author fullname="Geraint Luff" initials="G" surname="Luff">
            <address>
                <postal>
                    <street></street>
                    <city>Cambridge</city>
                    <country>UK</country>
                </postal>
                <email>luffgd@gmail.com</email>
            </address>
        </author>

        <date year="2017" />
        <workgroup>Internet Engineering Task Force</workgroup>
        <keyword>JSON</keyword>
        <keyword>Schema</keyword>
        <keyword>JavaScript</keyword>
        <keyword>Object</keyword>
        <keyword>Notation</keyword>
        <keyword>Hyper Schema</keyword>
        <keyword>Hypermedia</keyword>

        <abstract>
            <t>
                JSON Schema is a JSON based format for describing JSON data using various
                vocabularies.  This document specifies a vocabulary
                for annotating JSON documents with hyperlinks and instructions for processing and
                manipulating remote JSON resources through hypermedia environments such as HTTP.
            </t>
        </abstract>
        <note title="Note to Readers">
            <t>
                The issues list for this draft can be found at
                <eref target="https://github.com/json-schema-org/json-schema-spec/issues"/>.
            </t>
            <t>
                For additional information, see
                <eref target="http://json-schema.org/"/>.
            </t>
            <t>
                To provide feedback, use this issue tracker, the communication methods listed on the
                homepage, or email the document editors.
            </t>
        </note>
    </front>

    <middle>
        <section title="Introduction">
            <t>
                JSON Hyper-Schema is a JSON Schema vocabulary for annotating JSON documents
                with hyperlinks and instructions for processing and
                manipulating remote JSON resources through hypermedia environments such as HTTP.
            </t>
            <t>
                The term JSON Hyper-Schema is used to refer to a JSON Schema that uses these
                keywords.  The term "hyper-schema" on its own refers to a JSON Hyper-Schema
                within the scope of this specification.
            </t>

            <t>
                This specification will use the concepts, syntax, and terminology defined by the
                <xref target="json-schema">JSON Schema core</xref> and
                <xref target="json-schema-validation">JSON Schema validation</xref> specifications.
                It is advised that readers have a copy of these specifications.
            </t>
        </section>

        <section title="Conventions and Terminology">
            <t>
                <!-- The text in this section has been copied from the official boilerplate,
                and should not be modified.-->

                The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
                "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
                interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
            </t>

            <t>
                The terms "schema" and "instance" are to be interpreted as defined in the
                <xref target="json-schema">JSON Schema core specification</xref>.
            </t>
        </section>

        <section title="Overview">
            <t>
                JSON Hyper-Schema makes it possible to build hypermedia systems from JSON
                documents by describing how to construct hyperlinks from instance data.
            </t>
            <t>
                The combination of a JSON instance document and a valid application/schema+json
                hyper-schema for that instance behaves as a single hypermedia representation.
                By allowing this separation, hyper-schema-based systems can gracefully support
                applications that expect plain JSON, while providing full hypermedia capabilities
                for hyper-schema-aware applications and user agents.
            </t>
            <t>
                Client-side user agents can detect the presence of hyper-schema by looking for
                the application/schema+json media type and a "$schema" value that indicates the
                presence of the hyper-schema vocabulary.  A user agent can then use an
                implementation of JSON Hyper-Schema to provide an interface to the
                combination of the schema and instance documents as a single logical
                representation of a resource, just as with any single-document hypermedia
                representation format.
            </t>
            <t>
                Hyper-schemas allow representations to take up fewer bytes on the wire, and
                distribute the burden of link construction from the server to each client.
                A user agent need not construct a link unless a client application requests
                that link.
            </t>
            <t>
                JSON Hyper-Schema can also be used on the server side to generate other
                link serializations at runtime, such as HTTP Link headers or
                <xref target="I-D.kelly-json-hal">JSON HAL</xref>.  Because hyper-schema offers
                a superset of the features of many other systems, using it on the server
                can make it easier to support multiple representation media types and
                linking mechanisms.  It is even possible to support features such as JSON HAL's
                embedded resources by automatically following links on the server and
                inlining the results.
            </t>
        </section>

        <section title="Meta-schema">
            <t>
                The current URI for the JSON Hyper-Schema meta-schema is
                <eref target="http://json-schema.org/draft-06/hyper-schema#">
                http://json-schema.org/draft-06/hyper-schema#</eref> (draft-06 version).
            </t>
        </section>

        <section title="General implementation requirements">
            <t>
                A JSON Hyper-Schema implementation is able to take a hyper-schema, an
                instance, and optionally an identification of a location within the instance
                (such as a JSON Pointer or a URI fragment appropriate for the media type),
                and produce information about any links that apply to that instance
                or location.  This information is returned in the form of URIs and/or JSON Pointers.
                Additionally, some fields are intended for direct use by user agents and
                client applications.
            </t>
            <t>
                At a high level, a conforming implementation will meet the following requirements.
                Each of these requirements is covered in more detail in the individual keyword
                sections and keyword group overviews.
            </t>
            <section title="Link discovery">
                <section title="By attachment location">
                    <t>
                        An implementation MUST find and make accessible all links in
                        all (sub)schemas against which this (sub)instance is valid.
                        These links MUST all be presented as a single set, regardless
                        of the number of subschemas involved.  Links that cannot fulfill
                        their "hrefRequired" keyword based on the instance and/or potential
                        client input MUST be excluded.
                    </t>
                </section>
                <section title="By link context location">
                    <t>
                        In addition to providing the set of links attached to a location in the
                        instance, an implementation that considers the entire instance and schema
                        at once MUST make accessible the set of links for which a given location
                        is the link's context.  All such links MUST be in at least one set of links
                        produced by examining all attachment locations in the instance.
                    </t>
                    <t>
                        Streaming implementations MAY opt to only provide links that have
                        already appeared in the stream rather than blocking in order to process
                        the entire stream (which may be unbounded).
                    </t>
                    <t>
                        Link sets based on a context can include links attached to elements
                        of an ordered array.  Implementations MUST preserve the order of
                        such links with respect to each other.
                    </t>
                </section>
            </section>
            <section title="Link usage">
                <section title="Target and context identification">
                    <t>
                        For a given link, an implementation MUST be able to identify the
                        link's context.  The identifier MUST either be an IRI or URI
                        that fully identifies the context, or an IRI or URI together
                        with a JSON Pointer if the context is not an entire resource
                        and the representation's media type does not allow constructing an
                        appropriate fragment.
                    </t>
                    <t>
                        For a given link, an implementation MUST be able to construct the
                        target IRI or URI based on the instance and, if "hrefSchema" is present,
                        client input.  When working with client input, the input data MUST be
                        pre-populated from the instance when a template variable matches instance
                        data and is present in "hrefSchema".
                    </t>
                    <t>
                        For both context and target URIs, this requirement includes
                        determining the correct base URI when the target is provided as
                        a relative reference.
                    </t>
                    <t>
                        In order to encourage treating context and target URIs as opaque
                        identifiers, implementations MAY opt to hide those fields that
                        are only used in URI construction: "href", "hrefPointers", "hrefRequired",
                        "anchor", and "anchorPointer".  Implementations MAY offer a configuration
                        option to enable or disable encapsulation.
                    </t>
                </section>
                <section title="Recognizing standard link relation types">
                    <t>
                        Implementations MUST recognize a link with a "self" relation typd as
                        describing the possible interactions with the resource represented by
                        the instance data.  Collections MUST be recognized based on traversing
                        a "collection" link, and MAY be recognized based on the presence of
                        an "item" link which has as its context the instance or a sub-instance.
                    </t>
                </section>
                <section title="Providing access to target attributes and input schemas">
                    <t>
                        For a given link, an implementation MUST make the values of all
                        target attribute keywords directly available to the client.
                        Implementations MAY provide additional interfaces for using this
                        information, which is discussed in each keyword's section.
                    </t>
                    <t>
                        For a given link, an implementation MUST make the value of each
                        input schema keyword directly available to the client.
                    </t>
                </section>
            </section>
            <section title="Additional functionality">
                <t>
                    Implementations MAY provide additional functionality coordinating the use of
                    JSON Hyper-Schema with other specifications, including but not limited to
                    JSON Schema validation, serializing payloads based on media types, and
                    communicating with resources via protocols as indicated by URI schemes.
                    <cref>
                        This is vague.  I'm trying to convey that most uses of Hyper-Schema
                        would benefit from including integration with the media types, URI schemes,
                        and protocols, such as automatically validating submission data against
                        "submissionSchema", encoding it according to "submissionMediaType", examining
                        the URI for the "http" or "https" scheme, validating JSON representations of
                        headers against "headerSchema", serializing them into HTTP header format,
                        and constructing the appropriate POST request.  While many of those
                        activities are technically outside of the scope of Hyper-Schema,
                        coordinating all of them is specific to Hyper-Schema and beneficial
                        to automate.
                    </cref>
                </t>
            </section>
        </section>
        <section title="Schema keywords">
            <t>
                As with all JSON Schema keywords, all keywords described in this section
                are optional. The minimal valid JSON Hyper-schema is the blank object.
            </t>
            <section title="Interaction with validation">
                <t>
                    Hyper-schema keywords can be applied when the instance is valid against
                    the schema that includes those keywords.
                </t>
                <t>
                    Hyper-schemas MUST NOT be applied to an instance if the instance fails to
                    validate against the validation keywords within or containing the hyper-schema.
                    Hyper-schema keywords in branches of an "anyOf", "oneOf", or "if"/"then"/"else"
                    that do not validate, or in a "dependencies" subschema that is not relevant
                    to the instance, MUST be ignored.
                </t>
                <t>
                    Hyper-schema keywords in a subschema contained within a "not", at any depth,
                    including any number of intervening additional "not" subschemas, MUST be
                    ignored.
                </t>
                <t>
                    If the subschema for a "contains" keyword contains hyper-schema keywords they
                    MUST be applied to all array elements that validate against the schema.  While
                    finding a single validating element is sufficient to determine the validation
                    outcome, when hyper-schema keywords are present, the subschema MUST be evaluated
                    against all array elements.
                </t>
            </section>

            <section title="base">
                <t>
                    If present, this keyword is resolved against the current URI base that the
                    entire instance is found within, and sets the new URI base for URI references
                    within the instance.
                    It is therefore the first URI Reference resolved, regardless of the order in
                    which it was found.
                </t>
                <t>
                    The URI is computed from the provided URI template using the same process
                    described for the <xref target="href">"href"</xref> property of a Link
                    Description Object.
                </t>
            </section>

            <section title="links">
                <t>
                    The "links" property of schemas is used to associate Link Description Objects
                    with instances.  The value of this property MUST be an array, and the items in
                    the array must be Link Description Objects, as defined below.
                </t>
            </section>
        </section>

        <section title="Link Description Object">
            <t>
                <cref>
                    This section references the work-in-progress RFC5988bis, with the expectation
                    that it will reach RFC before this specification does.
                </cref>
                A Link Description Object (LDO) is a serialization of the abstract link model
                defined in <xref target="I-D.nottingham-rfc5988bis">RFC 5988bis, section 2</xref>.
                As described in that document, a link consists of a context, a relation type,
                a target, and optionally target attributes.  JSON Hyper-Schema's LDO provides
                all of these, along with additional features using JSON Schema to describe input
                for use with the links in various ways.
            </t>
            <t>
                Due to the use of URI Templates to identify link targets, as well as further use
                of client input, an LDO is a link template that may resolve to multiple links when
                used with a JSON instance document.
            </t>
            <t>
                A specific use of an LDO, typically involving a request and response across
                a protocol, is referred to as an operation.  For many protocols, multiple
                operations are possible on any given link.
            </t>
            <t>
                A Link Description Object MUST be an object, and the
                <xref target="href">"href"</xref> and <xref target="rel">"rel"</xref> properties
                MUST be present.  Each keyword is covered briefly in this section, with additional
                usage explanation and comprehensive examples given later in the document.
            </t>
            <t>
                The link description format can be used without JSON Schema, and use of this format
                can be declared by referencing the normative link description schema as the schema
                for the data structure that uses the links.
                The URI of the normative link description schema is:
                <eref target="http://json-schema.org/draft-06/links#">
                http://json-schema.org/draft-06/links#</eref> (draft-06 version).
            </t>

            <section title="Link context" anchor="context">
                <t>
                    In JSON Hyper-Schema, the link's context resource is, by default, the specific
                    location in the instance that validates against the schema containing the LDO.
                    This is often not the entire instance document.  This default context can
                    be changed using the keywords in this section.
                </t>
                <t>
                    Depending on the media type of the instance, it may or may not be possible
                    to assign a URI to the exact default context resource.  In particular,
                    application/json does not define URI fragment resolution semantics, so
                    properties or array elements within a plain JSON document cannot be identified
                    by a URI.  When it is not possible to produce a complete URI, the position
                    of the context SHOULD be conveyed by a the URI of the instance document,
                    together with a separate plain-string JSON Pointer.
                </t>
                <t>
                    Implementations MUST be able to construct the link context's URI, and
                    (if necessary for full identification), a JSON Pointer in string representation
                    form as per <xref target="RFC6901">RFC 6901, section 5</xref> in place of
                    a URI fragment.
                </t>
                <section title="anchor" anchor="anchor">
                    <t>
                        This property sets the context URI of the link.  The value of the property
                        MUST be resolved as a <xref target="RFC3986">URI-reference</xref> against
                        the base URI of the instance.
                    </t>
                </section>
                <section title="anchorPointer" anchor="anchorPointer">
                    <t>
                        This property changes the point within the instance that is considered
                        to be the context resource of the link.  The value of the property MUST
                        be a valid JSON Pointer in JSON String representation form, or a valid
                        <xref target="I-D.luff-relative-json-pointer">Relative JSON Pointer</xref>
                        which is evaluated relative to the default context.
                    </t>
                    <t>
                        While an alternate context with a known URI is best set with the
                        <xref target="anchor">"anchor"</xref> keyword, the lack of a fragment
                        identifier syntax for application/json means that it is usually not
                        possible to change the context within a JSON instance using a URI.
                    </t>
                    <t>
                        Even in "+json" media types that define JSON Pointer as a fragment
                        identifier syntax, if the default context is nested within an array,
                        it is not possible to obtain the index of the default context's position
                        in that array in order to construct a pointer to another property in that
                        same nested JSON object.  This will be demonstrated in the examples.
                    </t>
                    <t>
                        The result of processing this keyword SHOULD be a URI fragment if the
                        media type of the instance allows for such a fragment.  Otherwise it
                        MUST be a string-encoded JSON Pointer.
                    </t>
                </section>
            </section>
            <section title="Link relation type" anchor="relationType">
                <t>
                    The link's relation type identifies its semantics.  It is the primary
                    means of conveying how an application can interact with a resource.
                </t>
                <t>
                    Relationship definitions are not normally media type
                    dependent, and users are encouraged to utilize the most
                    suitable existing accepted relation definitions.
                </t>
                <section title="rel" anchor="rel">
                    <t>
                        The value of this property MUST be a string, and MUST be a single
                        Link Relation Type as defined in RFC 5988bis, Section 2.1.
                    </t>
                    <t>
                        This property is required.
                    </t>
                </section>
                <section title='"self" links' anchor="self">
                    <t>
                        A hyper-schema implementation MUST recognize that a link with relation
                        type "self" describes how a user agent can interact with the resource
                        represented by the instance.  A "self" link MUST be resolvable
                        from the instance, and therefore "hrefSchema" MUST NOT be present.
                        Hyper-schema authors SHOULD use "hrefRequired" to ensure that the
                        "self" link has all instance data that is needed for use.
                    </t>
                </section>
                <section title='"collection" and "item" links' anchor="collectionAndItem">
                    <t>
                        <xref target="RFC6573">RFC 6573</xref> defines and registers
                        the "item" and "collection" link relation types.  JSON Hyper-Schema imposes
                        additional semantics on collection resources indicated by these types.
                    </t>
                    <t>
                        Implementations MUST recognize the target of a "collection" link as
                        a collection, and SHOULD recognize that the context resource of an
                        "item" link is a collection.
                    </t>
                    <t>
                        A well-known design pattern in hypermedia is to use a collection resource
                        to create a member of the collection and give it a server-assigned URI.
                        If the protocol indicated by the URI scheme defines a specific method
                        that is suited to creating a resource with a server-assigned URI, then
                        a collection resource, as identified by these link relation types,
                        MUST NOT define semantics for that method that conflict with the semantics
                        of creating a collection member.  Collection resources MAY implement
                        item creation via such a protocol method.
                    </t>
                    <t>
                        As such a method would correspond to JSON Hyper-Schema's data submission
                        concept, the <xref target="submissionSchema">"submissionSchema"</xref>
                        field for the link SHOULD be compatible with the schema of the
                        representation of the collection's items, as indicated by the "item" link's
                        target resource or the "self" link of the "collection" link's context
                        resource.
                    </t>
                </section>
                <section title="Using extension relation types" anchor="extensionRelationTypes">
                    <t>
                        When no registered relation (aside from "related") applies, users are
                        encouraged to mint their own extension relation types, as described in
                        <xref target="RFC5988">section 4.2 of RFC 5988</xref>.  The simplest
                        approaches for choosing link relation type URIs are to either use
                        a URI scheme that is already in use to identify the system's primary
                        resources, or to use a human-readable, non-dereferenceable URI scheme
                        such as <xref target="RFC4151">"tag", defined by RFC 4151</xref>.
                    </t>
                    <t>
                        Extension relation type URIs need not be dereferenceable, even when
                        using a scheme that allows it.
                    </t>
                </section>
            </section>
            <section title="Link target" anchor="target">
                <t>
                    The keywords in this section are used to construct the target URI, potentially
                    making use of instance data.  The <xref target="hrefSchema">"hrefSchema"</xref>
                    keyword can be used to modify this process by introducing user input, as
                    described in the <xref target="input">link input</xref> section.
                </t>
                <section title="href" anchor="href">
                    <t>
                        The value of the "href" link description property is a template used to
                        determine the target URI of the related resource.
                        The value of the instance property MUST be resolved as a
                        <xref target="RFC3986">URI-reference</xref> against the base URI of the
                        instance.
                    </t>
                    <t>
                        This property is REQUIRED.
                    </t>
                </section>
                <section title="hrefPointers" anchor="hrefPointers">
                    <t>
                        The value of the "hrefPointers" link description property MUST be
                        an object.  Each property value in the object MUST be a valid
                        <xref target="RFC6901">JSON Pointer</xref>, or a valid
                        <xref target="I-D.luff-relative-json-pointer">Relative JSON Pointer</xref>
                        which is evaluated relative to the position in the instance from which
                        <xref target="href">"href"</xref> template variable resolution would
                        normally begin.
                    </t>
                    <t>
                        For each property name in the object that matches a variable name in the
                        "href" URI Template, the value of that property adjusts the starting position
                        of variable resolution for that variable.  Properties which do not match
                        "href" template variable names MUST be ignored.
                    </t>
                </section>
                <section title="hrefRequired" anchor="hrefRequired">
                    <t>
                        The value of this keyword MUST be an array, and the elements MUST be unique.
                        Each element SHOULD match a variable in the link's URI Template, without
                        percent-encoding.  After completing the entire URI Template resolution
                        process, if any variable that is present in this array does not have
                        a value, the link MUST NOT be used.
                    </t>
                </section>

                <section title="URI Templating">
                    <t>
                        The value of "href" is to be used as a URI Template, as defined in
                        <xref target="RFC6570">RFC 6570</xref>.
                    </t>

                    <section title="Values for substitution">
                        <t>
                            Each template variable is independently resolved to a value.  The
                            resolution process starts from the position in the instance to which
                            the link is attached.
                        </t>
                        <t>
                            Each template variable is independently resolved to a value.
                            For a given variable name in the URI Template, the value to use is
                            determined as follows.  In all cases, if there is no value at
                            the given location, implementations MUST proceed to the next step
                            without setting a value for the variable.
                            <list>
                                <t>
                                    If the variable name is present in
                                    <xref target="hrefPointers">"hrefPointers"</xref>, then
                                    the instance value to which the "hrefPointers" value points
                                    MUST be used.
                                </t>
                                <t>
                                    Otherwise, the value is looked up from the position in the
                                    instance to which the link is attached:
                                    <list>
                                        <t>
                                            If the data is an array, and the variable name is a
                                            representation of a non-negative integer, then the
                                            value at the corresponding array index MUST be used.
                                        </t>
                                        <t>
                                            Otherwise, the variable name should be
                                            percent-decoded, and the corresponding object property
                                            MUST be used.
                                        </t>
                                    </list>
                                </t>
                            </list>
                            This results in a data set mapping template variable names to values
                            loaded from instance data.
                        </t>
                        <t>
                            Next, if <xref target="hrefSchema">"hrefSchema"</xref> is present,
                            then it is processed starting with this data set, as described in
                            its section.
                        </t>
                        <t>
                            Finally, if <xref target="hrefRequired">"hrefRequired"</xref> is
                            present, if any template variable that is present in "hrefRequired"
                            still does not have a value, then the link MUST NOT be used.
                        </t>
                        <t>
                            Otherwise, the data set is converted to strings as needed and used
                            with the URI Template resolution process specified in RFC 7560.
                        </t>

                        <section title="Converting to strings">
                            <t>
                                When any value referenced by the URI template is null, a boolean or
                                a number, then it should first be converted into a string as
                                follows:
                                <list>
                                    <t>
                                        null values SHOULD be replaced by the text "null"
                                    </t>
                                    <t>
                                        boolean values SHOULD be replaced by their lower-case
                                        equivalents: "true" or "false"
                                    </t>
                                    <t>
                                        numbers SHOULD be replaced with their original JSON
                                        representation.
                                    </t>
                                </list>
                            </t>
                            <t>
                                In some software environments the original JSON representation of a
                                number will not be available (there is no way to tell the difference
                                between 1.0 and 1), so any reasonable representation should be used.
                                Schema and API authors should bear this in mind, and use other types
                                (such as string or boolean) if the exact representation is
                                important.
                            </t>
                        </section>
                    </section>
                </section>
            </section>
            <section title="Link target attributes">
                <section title="title">
                    <t>
                        This property defines a title for the link.
                        The value MUST be a string.
                    </t>

                    <t>
                        User agents MAY use this title when presenting the link to the user.
                    </t>
                </section>

                <section title="description">
                    <t>
                        This property provides additional information beyond what
                        is present in the title.  The value MUST be a string.
                        While a title is preferably short, a description can be
                        used to go into more detail about the purpose and usage
                        of the link.
                    </t>

                    <t>
                        User agents MAY use this description when presenting
                        the link to the user.
                    </t>
                </section>

                <section title="targetSchema" anchor="targetSchema">
                    <t>
                        This property provides a schema that is expected to describe
                        the link target's representation.  Depending on the protocol,
                        the schema may or may not describe the response to any particular
                        request sent to the link.  This property is advisory only.
                    </t>
                </section>

                <section title="targetHints" anchor="targetHints">
                    <t>
                        <cref>
                            This section attempts to strike a balance between comprehensiveness
                            and flexibility by deferring most of its structure to the protocol
                            indicated by the URI scheme.  Note that a resource can be identified
                            by a URI with a dereferenceable scheme, yet not be accessible over
                            that protocol.  While currently very loose, this section is expected
                            to become more well-defined based on draft feedback, and may change
                            significantly in future drafts.
                        </cref>
                    </t>
                    <t>
                        The value of this property is advisory only.  It represents information that
                        is expected to be discoverable through interacting with the target resource,
                        typically in the form of protocol-specific control information or meta-data
                        such as headers returned in response to an HTTP HEAD or OPTIONS request.
                        The protocol is determined by the "href" URI scheme, although note that
                        resources are not guaranteed to be accessible over such a protocol.
                    </t>
                    <t>
                        The value of this property SHOULD be an object.  The keys to this object
                        SHOULD be lower-cased forms of the control data field names.  Each value
                        SHOULD be an array, in order to uniformly handle multi-valued fields.
                        Multiple values MUST be presented as an array, and not as a single string.
                    </t>
                    <t>
                        Protocols with control information not suitable for representation as
                        a JSON object MAY be represented by another data type, such as an array.
                    </t>
                    <t>
                        Values that cannot be understood as part of the indicated protocol MUST
                        be ignored by a JSON Hyper-Schema implementation.  Applications MAY make
                        use of such values, but MUST NOT assume interoperability with other
                        implementations.
                    </t>
                    <t>
                        Implementations MUST NOT assume that all discoverable information is
                        accounted for in this object.  Clients MUST properly handle run-time responses
                        that contradict this property's values.
                    </t>
                    <t>
                        Clients MUST NOT assume that an implementation will automatically take any
                        action based on the value of this property.
                    </t>
                </section>

                <section title="targetMediaType">
                    <t>
                        The value of this property is advisory only, and represents the media type
                        <xref target="RFC2046">RFC 2046</xref>, that is expected to be returned when
                        fetching this resource.
                        This property value MAY be a media range instead, using the same pattern defined
                        in <xref target="RFC7231">RFC 7231, section 5.3.2 - HTTP "Accept" header</xref>.
                    </t>

                    <t>
                        This property is analogous to the "type" property of &lt;a&gt; elements in HTML
                        (advisory content type), or the "type" parameter in the
                        <xref target="RFC5988">HTTP Link header</xref>.
                        User agents MAY use this information to inform the interface they present to the
                        user before the link is followed, but this information MUST NOT use this
                        information in the interpretation of the resulting data.
                        When deciding how to interpret data obtained through following this link, the
                        behaviour of user agents MUST be identical regardless of the value of the this
                        property.
                    </t>

                    <t>
                        If this property's value is specified, and the link's target is to be obtained
                        using any protocol that supports the HTTP/1.1 "Accept" header
                        <xref target="RFC7231">RFC 7231, section 5.3.2</xref>, then user agents MAY use
                        the value of this property to aid in the assembly of that header when making the
                        request to the server.
                    </t>

                    <t>
                        If this property's value is not specified, then the value should be taken to be
                        "application/json".  Hyper-Schema authors SHOULD NOT use a protocol-specific
                        value in <xref target="targetHints">"targetHints"</xref> for this purpose.
                    </t>
                </section>
            </section>
            <section title="Link input" anchor="input">
                <t>
                    There are several ways that a client can use data with a link:
                    <list>
                        <t> URI Template variables resolved from server-supplied instance data </t>
                        <t> URI Template variables resolved from user agent data </t>
                        <t> Replacing or modifying the target resource's representation </t>
                        <t> Submitting data for processing, where the data has no
                            inherent relation to the target resource's representation</t>
                    </list>
                    The three ways to use client-supplied data are each addressed by a separate
                    schema keyword within the link description object.  When performing operations,
                    clients SHOULD ignore schemas that are not relevant to their semantics.
                </t>
                <section title="hrefSchema" anchor="hrefSchema">
                    <t>
                        The value of the "hrefSchema" link description property MUST be
                        a valid JSON Schema.  This schema is used to validate user input
                        or other user agent data for filling out the URI Template in
                        <xref target="href">"href"</xref>.
                    </t>
                    <t>
                        Omitting "hrefSchema" or setting the entire schema to "false" prevents
                        any user agent data from being accepted.  In this case, resolution
                        of the template proceeds to the next step as specified under
                        "URI Templating" without interruption.
                    </t>
                    <t>
                        If "hrefSchema" is present and not false, then the implementation
                        MUST allow for input.  The input data MUST be pre-populated with
                        the values from the data set produced up to this point in the URI
                        template resolution step.
                        <cref>
                            What if additional properties are allowed?  Is the entire data
                            set pre-populated even for fields that are not described directly
                            by "hrefSchema"?  This would make sense if there is an explicit
                            schema for "additionalProperties".  What if additional properties
                            are *NOT* allowed?  Should validation fail if the data set has
                            properties not accounted for in "hrefSchema" or should those
                            variables be excluded from pre-population?
                        </cref>
                    </t>
                    <t>
                        After input is accepted, potentially overriding the pre-populated
                        instance data, the resulting data set MUST successfully validate
                        against the value of "hrefSchema".  If it does not then the link
                        MUST NOT be used.  If it is valid, then the process given in the
                        "URI Templating" section continues with this updated data set.
                    </t>
                    <t>
                        Let's try:
                        * Create an empty object.  This is the template data set.
                        * Adjust locations with "hrefPointer"
                        * Populate the object with variable names and values for each
                          variable that resolves from an instance location with a value.
                        * If "hrefSchema":
                            * Create an empty object.  This is the input data set.
                            * Pre-populate the input data set from the template data set.
                            * Validate each input data set field individually against "hrefSchema"
                            * If a field is present and fails to validate, remove it from
                              the input data set, but *not* from the template data set.
                            * Present an input interface pre-populated with the input data set
                            * Accept input, and validate the entire resulting input data set
                              against "hrefSchema".  If it fails, stop processing.
                            * Update the template data set with the input data set, overridding
                              any variable that appears in both with the input data set's value.
                        * If "hrefRequired" lists any fields that are not present in the template
                          data set with a (potentially null) value, stop processing.
                        * Use the resulting template data set in the RFC 6570 resolution process.
                    </t>
                </section>

                <section title="headerSchema" anchor="headerSchema">
                    <t>
                        <cref>
                            As with "targetHints", this keyword is somewhat under-specified
                            to encourage experimentation and feedback as we try to balance
                            flexibility and clarity.
                        </cref>
                    </t>
                    <t>
                        If present, this property is a schema for protocol-specific request
                        headers or analogous control and meta-data.  The value of this
                        object MUST be a valid JSON Schema.
                        The protocol is determined by the "href" URI scheme, although note that
                        resources are not guaranteed to be accessible over such a protocol.
                        The schema is advisory only; the target resource's behavior is not
                        constrained by its presence.
                    </t>
                    <t>
                        The purpose of this keyword is to advertise target resource interaction
                        features, and indicate to clients what headers and header values are
                        likely to be useful.  Clients MAY use the schema to validate relevant
                        headers, but MUST NOT assume that missing headers or values are forbidden
                        from use.  While schema authors MAY set "additionalProperties" to
                        false, this is NOT RECOMMENDED and MUST NOT prevent clients or user agents
                        from supplying additional headers when requests are made.
                    </t>
                    <t>
                        The exact mapping of the JSON data model into the headers is
                        protocol-dependent.  However, in most cases this schema SHOULD
                        specify a type of "object", and the property names SHOULD be
                        lower-cased forms of the control data field names.
                    </t>
                    <t>
                        "headerSchema" is applicable to any request method or command that the
                        protocol supports.  When generating a request, clients SHOULD ignore
                        schemas for headers that are not relevant to that request.
                    </t>
                </section>
                <section title="Manipulating the target resource representation">
                    <t>
                        In JSON Hyper-Schema, <xref target="targetSchema">"targetSchema"</xref>
                        supplies a non-authoritative description of the target resource's
                        representation. A client can use "targetSchema" to structure input for
                        replacing or modifying the representation, or as the base representation
                        for buildign a patch document based on a patch media type.
                    </t>
                    <t>
                        Alternatively, if "targetSchema" is absent or if the client prefers to
                        only use authoritative information, it can interact with the target
                        resource to confirm or discover its representation structure.
                    </t>
                    <t>
                        "targetSchema" is not intended to describe link operation responses,
                        except when the response semantics indicate that it is a representation
                        of the target resource.  In all cases, the schema indicated by the response
                        itself is authoritative.
                    </t>
                </section>
                <section title="Submitting data for processing">
                    <t>
                        The <xref target="submissionSchema">"submissionSchema"</xref> and
                        <xref target="submissionMediaType">"submissionMediaType"</xref> keywords
                        describe the domain of the processing function implemented by the target
                        resource. Otherwise, as noted above, the submission schema and media type
                        are ignored for operations to which they are not relevant.
                    </t>

                    <section title="submissionMediaType" anchor="submissionMediaType">
                        <t>
                            If present, this property indicates the media type format the
                            client should use for the request payload described by
                            <xref target="submissionSchema">"submissionSchema"</xref>.
                        </t>
                        <t>
                            Omitting this keyword has the same behavior as a value of
                            application/json.
                        </t>
                        <t>
                            Note that "submissionMediaType" and "submissionSchema"
                            are not restricted to HTTP URIs.
                            <cref>This statement might move to wherever the example ends up.</cref>
                        </t>
                    </section>

                    <section title="submissionSchema" anchor="submissionSchema">
                        <t>
                            This property contains a schema which defines the acceptable structure
                            of the document to be encoded according to the "submissionMediaType"
                            property and sent to the target resource for processing.  This can be
                            viewed as describing the domain of the processing function implemented
                            by the target resource.
                        </t>
                        <t>
                            This is a separate concept from the
                            <xref target="targetSchema">"targetSchema"</xref> property, which
                            describes the target information resource (including for replacing the
                            contents of the resource in a PUT request), unlike "submissionSchema"
                            which describes the user-submitted request data to be evaluated by the
                            resource. "submissionSchema" is intended for use with requests that
                            have payloads that are not necessarily defined in terms of the target
                            representation.
                        </t>
                        <t>
                            Omitting "submissionSchema" or setting the entire schema to "false"
                            prevents any user agent data from being accepted.
                            <cref>
                                Is this correct?  In draft-06 this was the only way to signal
                                support for data submission, but now we have "targetHints" for
                                that.  It may make more sense for this to default to behaving
                                as if the schema is set to true.
                            </cref>
                        </t>
                    </section>
                </section>
            </section>
        </section>

        <section title="Security Considerations">
            <section title="Security Considerations for &quot;self&quot; links">
                <t>
                    When link relation of "self" is used to denote a full representation of an
                    object, the user agent SHOULD NOT consider the representation to be the
                    authoritative representation of the resource denoted by the target URI if
                    the target URI is not equivalent to or a sub-path of the URI used to request
                    the resource representation which contains the target URI with the "self"
                    link.
                </t>
            </section>
            <section title="Security Considerations for &quot;targetSchema&quot;">
                <t>
                    This property has similar security concerns to that of "targetMediaType".
                    Clients MUST NOT use the value of this property to aid in the interpretation
                    of the data received in response to following the link, as this leaves
                    "safe" data open to re-interpretation.
                </t>
            </section>
            <section title="Security concerns for &quot;targetMediaType&quot;">
                <t>
                    The "targetMediaType" property in link definitions defines the expected
                    format of the link's target.
                    However, this is advisory only, and MUST NOT be considered authoritative.
                </t>

                <t>
                    When choosing how to interpret data, the type information provided by the
                    server (or inferred from the filename, or any other usual method) MUST be
                    the only consideration, and the "targetMediaType" property of the link
                    MUST NOT be used.
                    User agents MAY use this information to determine how they represent the
                    link or where to display it (for example hover-text, opening in a new tab).
                    If user agents decide to pass the link to an external program, they SHOULD
                    first verify that the data is of a type that would normally be passed to
                    that external program.
                </t>

                <t>
                    This is to guard against re-interpretation of "safe" data, similar to the
                    precautions for "targetSchema".
                </t>
            </section>
        </section>
<!--
        <section title="IANA Considerations">
            <t>No considerations</t>
        </section>
-->
        <section title="Acknowledgments">
            <t>
                Thanks to
                Gary Court,
                Francis Galiegue,
                Kris Zyp,
                and Geraint Luff
                for their work on the initial drafts of JSON Schema.
            </t>
            <t>
                Thanks to
                Jason Desrosiers,
                Daniel Perrett,
                Erik Wilde,
                Ben Hutton,
                Evgeny Poberezkin,
                Brad Bowman,
                Gowry Sankar,
                Donald Pipowitch,
                Dave Finlay,
                and Denis Laxalde
                for their submissions and patches to the document.
            </t>
        </section>
    </middle>

    <back>
        <!-- References Section -->
        <references title="Normative References">
            &rfc2119;
            &rfc3986;
            <!--&rfc4287;-->
            &rfc6570;
            &rfc6901;
            &I-D.luff-relative-json-pointer;
            &I-D.reschke-http-jfv;
            <reference anchor="json-schema">
                <front>
                    <title>JSON Schema: A Media Type for Describing JSON Documents</title>
                    <author initials="A." surname="Wright">
                        <organization/>
                    </author>
                    <date year="2016" month="October"/>
                </front>
                <seriesInfo name="Internet-Draft" value="draft-wright-json-schema-01" />
            </reference>
            <reference anchor="json-schema-validation">
                <front>
                    <title>JSON Schema Validation: A Vocabulary for Structural Validation of JSON</title>
                    <author initials="A." surname="Wright">
                        <organization/>
                    </author>
                    <date year="2016" month="October"/>
                </front>
                <seriesInfo name="Internet-Draft" value="draft-wright-json-schema-validation-01" />
            </reference>
        </references>
        <references title="Informative References">
            &rfc2046;
            <!--&rfc5226;-->
            &rfc4151;
            &rfc5789;
            &rfc5988;
            &rfc6573;
            &rfc7231;
            &I-D.nottingham-rfc5988bis;
            &I-D.kelly-json-hal;
            &ldp;
        </references>
        <section title="JSON Hyper-Schema and HTTP">
            <t>
                While JSON Hyper-Schema is a hypermedia format and therefore protocol-independent,
                its most common expected use is in HTTP systems, or systems using protocols
                such as CoAP which are explicitly analogous to HTTP.
            </t>
            <t>
                This appendix provides guidance on how to define links for use with each
                common HTTP method, and how collection resources impose additional constarints
                on the use of HTTP POST.  Additionaly, guidance is provided on hinting at
                HTTP response header values and describing possible HTTP request headers
                that are relevant to the given resource.
            </t>
            <section title="One link per target and relation type">
                <t>
                    Link Description Objects do not directly indicate what operations, such
                    as HTTP methods, are supported by the target resource.  Instead, operations
                    should be inferred primarily from link <xref target="rel">relation types</xref>
                    and URI schemes.
                </t>
                <t>
                    This means that for each target resource and link relation type pair, schema
                    authors SHOULD only define a single LDO.  While it is possible to use
                    "allow" with "targetHints" to repeat a relation type and target pair with
                    different HTTP methods marked as allowed, this is NOT RECOMMENDED and may
                    not be well-supported by conforming implementations.
                </t>
                <t>
                    All information necessary to use each HTTP method can be conveyed in a
                    single LDO as explained in this appendix.
                </t>
                <t>
                    Note, however, that a resource may always decline an operation at runtime,
                    for instance due to authorization failure, or due to other application state
                    that controls the operation's availability.
                </t>
            </section>
            <section title="&quot;targetSchema&quot; and HTTP" anchor="targetHTTP">
                <t>
                    The relationship between a resource's representation and HTTP requests and
                    responses is determined by <xref target="RFC7231">RFC 7231, section 4.3.1 -
                        "GET", section 4.3.4 "PUT", and section 3.1.4.2,
                        "Content-Location"</xref>. In particular, "targetSchema" suggests what a
                    client can expect for the response to an HTTP GET or any response for which
                    the "Content-Location" header is equal to the request URI, and what a client
                    should send if it replaces the resource in an HTTP PUT request.
                </t>
                <t>
                    The media type of the representation is given by the "targetMediaType"
                    field.  Alternatively, possible available media types MAY be advertised
                    using an entry for the "Accept" request header field in "headerSchema".
                </t>
                <t>
                    Per <xref target="RFC5789">RFC 5789</xref>, the request structure for an HTTP
                    PATCH is determined by the combination of "targetSchema" and the request
                    media type, which is conveyed by the "Accept-Patch" header.
                </t>
                <t>
                    HTTP POST requests are determined by the "submissionSchema" and
                    "submissionMediaType" fields.  Alternatively, the "Accept-Post" header has
                    been defined and registered by the
                    <xref target="W3C.REC-ldp-20150226">Linked Data Platform</xref>, and MAY be
                    advertised via the "targetHints" field.
                    <cref>
                        What happens if both are used?  Also, "submissionSchema" is a MUST
                        to support, while "targetHints" are at most a SHOULD.  But forbidding
                        the use of "Accept-Post" in "targetHints" seems incorrect.
                    </cref>
                </t>
            </section>
            <section title='Optimizing HTTP discoverability with "targetHints"'>
                <t>
                    <cref>It would be good to also include a section with CoAP examples.</cref>
                </t>
                <t>
                    JSON serializations of HTTP response header information SHOULD follow the
                    guidelines established by the work in progress
                    <xref target="I-D.reschke-http-jfv">"A JSON Encoding for HTTP Header Field Values"</xref>.
                    Approaches shown in that document's examples SHOULD be applied to other
                    similarly structured headers wherever possible.
                </t>
                <t>
                    No distinction is made between headers that may appear in responses to
                    different methods, such as HEAD vs OPTIONS.
                </t>
                <t>
                    It is RECOMMENDED that schema authors provide hints for the values of
                    the following types of HTTP headers whenever applicable:
                    <list style="symbols">
                        <t>Method allowance</t>
                        <t>Method-specific request media types</t>
                        <t>Authentication challenges</t>
                    </list>
                </t>
                <t>
                    In general, headers that are likely to have different values at different
                    times SHOULD NOT be included in "targetHints".
                </t>
            </section>
            <section title='Advertising HTTP features with "headerSchema"'>
                <t>
                    Schemas SHOULD be written to describe JSON serializations that
                    follow guidelines established by the work in progress
                    <xref target="I-D.reschke-http-jfv">"A JSON Encoding for HTTP Header Field Values"</xref>
                    Approaches shown in that document's examples SHOULD be applied to
                    other similarly structured headers wherever possible.
                </t>
                <t>
                    It is RECOMMENDED that schema authors describe the available usage of
                    the following types of HTTP headers whenever applicable:
                    <list style="symbols">
                        <t>Content negotiation</t>
                        <t>Authentication and authorization</t>
                        <t>Range requests</t>
                        <t>The "Prefer" header</t>
                    </list>
                </t>
                <t>
                    Headers such as cache control and conditional request headers are generally
                    implemented by intermediaries rather than the resource, and are therefore
                    not generally useful to describe.  While the resource must supply the
                    information needed to use conditional requests, the runtime handling of
                    such headers and related responses is not resource-specific.
                </t>
            </section>
            <section title="Creating resources through collections">
                <t>
                    When using HTTP, or a protocol such as CoAP that is explicitly analogous
                    to HTTP, this is done by POST-ing a representation of the individual
                    resource to be created to the collection resource.
                </t>
            </section>
        </section>
        <section title="Using JSON Hyper-Schema in APIs" anchor="apis">
            <t>
                Hypermedia APIs, which follow the constraints of the REST architectural
                style, enable the creation of generic user agents.  Such a user agent
                has no application-specific knowledge.  Rather, it understands pre-defined
                media types, URI schemes, protocols, and link relations, often by recognizing
                these and coordinating the use of existing software that implement support
                for them.  Applications can then be built on top of such a user agent, focusing
                on their own semantics and logic rather than the mechanics of the interactions.
            </t>
            <t>
                JSON Hyper-Schema is ideal for representing individual resources in hypermedia
                APIs.  It offers comprehensive capabilities for describing how to use hyperlinks
                to interact with the current resource (through "self" links), or related
                resources.  Using a hyper-schema-based API involves traversing links from
                one resource to the next, interacting with resources through their
                representations as described by the target keywords, or submitting data
                to resources for processing using the submission keywords.
            </t>
            <t>
                Hyper-schema is only concerned with one resource and set of associated links
                at a time.  Just as a web browser works with only one HTML page at a time,
                with no concept of whether or how that page functions as part of a "site",
                a hyper-schema-aware user agent works with one resource at a time, without
                any concept of whether or how that resource fits into an API.
            </t>
            <t>
                While aspects of cross-cutting API concerns such as authentication
                and authorization may be described in hyper-schema, for instance in
                the headerSchema of a link, defining an API-wide approach to any
                cross-cutting concerns is beyond the scope of hyper-schema.
            </t>
            <section title="Separation of concerns">
                <t>
                    Working with a JSON Hyper-Schema-based API will generally involve
                    three components:  The hyper-schema implementation, a generic user agent,
                    and a client application.  The hyper-schema implementation's requirements
                    are given in this specification.  The generic user agent handles standardized
                    URI schemes, protocols, and media types.  User agents that handle HTTP,
                    HTTPS, and JSON, for instance, are available as libraries in many programming
                    languages.
                </t>
                <t>
                    The client application has the domain-specific knowledge of link relation
                    types and data structure fields needed to make use of the specific API.
                    A client application can use an available user agent library and a hyper-schema
                    implementation separately.  Alternatively, extensible user agents can allow
                    adding hyper-schema support as a plug-in alongside support for plain JSON, XML,
                    or other media types.
                </t>
                <t>
                    <cref>
                        Add something about generic user agents not being magic, HATEOAS, etc.
                    </cref>
                </t>
            </section>
            <section title="Resource evolution with Hyper-Schema">
                <t>
                    Since a given JSON Hyper-Schema is used with a single resource at a single
                    point in time, it has no inherent notion of versioning.  However, a given
                    resource can change which schema or schemas it uses over time, and the
                    URIs of these schemas can be used to indicate versioning information.
                    When used with a media type that supports indicating a schema with a media
                    type parameter, these versioned schema URIs can be used in content negotiation.
                </t>
                <t>
                    A resource can indicate that it is an instance of multiple schemas, which allows
                    supporting multiple compatible versions simultaneously.  A client application
                    can then make use of the hyper-schema that it recognizes, and ignore newer
                    or older versions.
                </t>
                <t>
                    Note that this notion of changing the representaiton version using
                    successive hyper-schemas is separate from deprecating an entire resource
                    and either removing it or replacing it with a new resource at a new URI.
                    The "targetHints" keyword can be used to convey deprecation information.
                </t>
                <t>
                    <cref>
                        This section is something of a placeholder, with the goal being to 
                        get readers to understand that while hyper-schema helps with versioning,
                        it does not and will not have explicit features to support it.
                    </cref>
                </t>
            </section>
            <section title="Entry point resource">
                <t>
                    To create an entry point for an API, it is RECOMMENDED to provide
                    a resource at a documented entry point URI with the minimal amount of data
                    necessary to begin interacting with API resources.
                    The hyper-schema for this resource SHOULD contain links to all
                    API resources that can be accessed with only user input and/or
                    data contained in the entry point resource's representation.
                </t>
            </section>
            <section title="Responses and errors">
                <t>
                    Because a hyper-schema represents a single resource at a time, it does not
                    provide for an enumeration of all possible responses to protocol operations
                    performed with links.  Each response, including errors, is considered
                    its own (possibly anonymous) resource, and should identify its own
                    hyper-schema to allow the user agent or client application to interpret any
                    information that is provided beyond the protocol's own status reporting.
                </t>
                <t>
                    Protocol and media type specifications provide the necessary information to
                    deal with different responses at runtime, while documenting all responses
                    is a concern static analysis across all hyper-schemas making up an API.
                </t>
            </section>
        </section>
        <section title="Static analysis of hyper-schemas">
            <t>
                It is possible to statically analyze a set of hyper-schemas without instance
                data in order to generate output such as documentation or code.  However,
                the full feature set of both validation and hyper-schema cannot be accessed
                without runtime instance data.
            </t>
            <t>
                This is an intentional design choice to provide the maximum runtime
                flexibility for hypermedia systems.  JSON Schema as a media type allows for
                establishing additional vocabularies for static analysis and content
                generation, which are not addressed in this specification.  Additionally,
                individual systems may restrict their usage to subsets that can be
                analyzed statically if full design-time description is a goal.
                <cref>
                    Vocabularies for API documentation and other purposes have been
                    proposed, and contributions are welcome at
                    https://github.com/json-schema-org/json-schema-vocabularies
                </cref>
            </t>
        </section>

        <section title="Change Log">
            <t>
                <cref>This section to be removed before leaving Internet-Draft status.</cref>
            </t>
            <t>
                <list style="hanging">
                    <t hangText="draft-wright-json-schema-hyperschema-02">
                        <list style="symbols">
                            <t></t>
                        </list>
                    </t>
                    <t hangText="draft-wright-json-schema-hyperschema-01">
                        <list style="symbols">
                            <t>Fixed examples</t>
                            <t>Added "hrefSchema" for user input to "href" URI Templates</t>
                            <t>Removed URI Template pre-processing</t>
                            <t>Clarified how links and data submission work</t>
                            <t>Clarified how validation keywords apply hyper-schema keywords and links</t>
                            <t>Clarified HTTP use with "targetSchema"</t>
                            <t>Renamed "schema" to "submissionSchema"</t>
                            <t>Renamed "encType" to "submissionEncType"</t>
                            <t>Removed "method"</t>
                        </list>
                    </t>
                    <t hangText="draft-wright-json-schema-hyperschema-00">
                        <list style="symbols">
                            <t>"rel" is now optional</t>
                            <t>rel="self" no longer changes URI base</t>
                            <t>Added "base" keyword to change instance URI base</t>
                            <t>Removed "root" link relation</t>
                            <t>Removed "create" link relation</t>
                            <t>Removed "full" link relation</t>
                            <t>Removed "instances" link relation</t>
                            <t>Removed special behavior for "describedBy" link relation</t>
                            <t>Removed "pathStart" keyword</t>
                            <t>Removed "fragmentResolution" keyword</t>
                            <t>Updated references to JSON Pointer, HTML</t>
                            <t>Changed behavior of "method" property to align with hypermedia best current practices</t>
                        </list>
                    </t>
                    <t hangText="draft-luff-json-hyper-schema-01">
                        <list style="symbols">
                            <t>Split from main specification.</t>
                        </list>
                    </t>
                </list>
            </t>
        </section>
    </back>
</rfc>
